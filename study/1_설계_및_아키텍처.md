# 1. AdvanceKeep 설계 및 아키텍처 분석

이 문서는 AdvanceKeep 프로젝트가 어떤 구조로 설계되었고, 왜 그런 기술적 선택을 했는지에 대한 아키텍처 관점의 학습 자료입니다.

## 1. 프로젝트 구조 (Directory Structure)
AdvanceKeep은 **관심사의 분리 (Separation of Concerns)** 원칙을 철저히 따르는 폴더 구조를 가지고 있습니다.

```
src/
├── components/     # UI를 구성하는 컴포넌트들
│   ├── features/   # 특정 기능(도메인)에 종속된 컴포넌트 (예: notes, drive)
│   ├── layout/     # 전체 레이아웃 (Header, Sidebar)
│   └── ui/         # 재사용 가능한 공용 UI (Button, Modal, Input)
├── hooks/          # 비즈니스 로직을 분리한 커스텀 훅 (useAuth, useNotes)
├── pages/          # 라우팅 단위가 되는 페이지 (Home, Login, Trash)
├── services/       # 외부 API(Firebase) 통신 로직
└── ...
```

### 💡 학습 포인트: 왜 이렇게 나누었을까?
*   **유지보수성**: UI 코드(`components`)와 데이터 처리 로직(`services`, `hooks`)이 섞여 있으면 코드가 복잡해집니다. 이를 분리함으로써 UI 수정 시 로직을 건드릴 필요가 없고, 반대로 로직 수정 시 디자인이 깨질 걱정이 줄어듭니다.
*   **재사용성**: `services` 폴더의 함수들은 컴포넌트와 무관하게 순수 자바스크립트 함수로 작성되어 있어, 어디서든 재사용이 가능합니다.

## 2. 디자인 패턴 (Design Patterns)

### 2.1 컨테이너-프레젠테이셔널 패턴 (Container-Presentational Pattern) 변형
최근 React 트렌드는 Hooks를 사용하여 이 패턴을 대체합니다.
*   **UI 컴포넌트**: 보여지는 것만 담당 (예: `NoteCard.jsx`)
*   **Custom Hooks**: 데이터와 로직 담당 (예: `useNotes.js`)

`Home.jsx`를 보면 직접 복잡한 계산을 하지 않고 `useNotes()` 훅을 통해 데이터(`notes`)와 함수(`addNote`)만 가져와서 사용합니다.

### 2.2 서비스 레이어 패턴 (Service Layer Pattern)
Firebase SDK를 컴포넌트에서 직접 호출하지 않고, `src/services/api.js`라는 중간 계층을 두었습니다.
*   **장점**: 만약 나중에 백엔드를 Firebase에서 Supabase나 자체 Node.js 서버로 바꾸더라도, `services/api.js` 파일만 수정하면 됩니다. 컴포넌트 코드는 수정할 필요가 없습니다.

## 3. 기술 스택 선정 이유

| 기술 | 역할 | 선정 이유 |
| :--- | :--- | :--- |
| **React** | 프론트엔드 라이브러리 | 컴포넌트 기반의 재사용성, 방대한 생태계, Virtual DOM을 통한 성능 최적화. |
| **Vite** | 빌드 도구 | CRA(Create React App) 대비 압도적으로 빠른 개발 서버 구동 및 빌드 속도 (Go 언어 기반 esbuild 사용). |
| **Firebase** | Backend-as-a-Service | 서버 구축 없이 인증(Auth), DB(Firestore), 호스팅을 한 번에 해결. 빠른 프로토타이핑에 최적. |
| **Capacitor** | 모바일 런타임 | 기존 웹 기술(React)을 그대로 사용하여 안드로이드/iOS 앱으로 패키징 가능. React Native보다 러닝 커브가 낮음. |

## 4. UI/UX 아키텍처
*   **Masonry Layout (Pinterest Style)**: 고정된 그리드가 아니라, 메모의 내용 길이에 따라 높이가 다른 카드들이 벽돌 쌓듯이 배치되는 구조. CSS의 `column-count` 속성을 활용하여 구현.
*   **Optimistic UI (낙관적 업데이트)**: 서버 응답을 기다리지 않고 UI를 먼저 업데이트하여 앱이 매우 빠르게 느껴지게 함. (상세 내용은 4강 참조)
