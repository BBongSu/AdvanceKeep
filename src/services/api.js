import { db } from './firebase';
import {
  collection,
  addDoc,
  getDocs,
  doc,
  updateDoc,
  deleteDoc,
  query,
  where,
  Timestamp,
  setDoc,
  documentId,
  getDoc,
} from 'firebase/firestore';

const NOTES_COLLECTION = 'notes';

/**
 * Firestore 문서를 앱에서 사용하는 Note 객체로 변환
 * - Timestamp 객체를 ISO 문자열로 변환하여 JSON 호환성 유지
 */
const docToNote = (doc) => {
  const data = doc.data();
  return {
    id: doc.id,
    ...data,
    // Convert Firestore Timestamp to ISO string if needed, or keeping it as is 
    // depending on frontend usage. Existing app likely expects ISO strings for dates 
    // if generated by new Date().toISOString()
    createdAt: data.createdAt instanceof Timestamp ? data.createdAt.toDate().toISOString() : data.createdAt,
    updatedAt: data.updatedAt instanceof Timestamp ? data.updatedAt.toDate().toISOString() : data.updatedAt,
  };
};

/**
 * 메모 목록 불러오기
 * @param {string} userId - 현재 사용자 ID
 * @returns {Array} 사용자가 작성한 메모 + 공유받은 메모
 */
export const fetchNotes = async (userId) => {
  if (!userId) return [];

  const notesRef = collection(db, NOTES_COLLECTION);

  // 1. 내가 작성한 메모 조회
  const ownedQuery = query(
    notesRef,
    where('userId', '==', userId)
  );

  // 2. 나에게 공유된 메모 조회 ('sharedWith' 배열에 내 ID가 포함된 것)
  const sharedQuery = query(
    notesRef,
    where('sharedWith', 'array-contains', userId)
  );

  const [ownedSnapshot, sharedSnapshot] = await Promise.all([
    getDocs(ownedQuery),
    getDocs(sharedQuery),
  ]);

  const ownedNotes = ownedSnapshot.docs.map(docToNote);
  const sharedNotes = sharedSnapshot.docs.map(docToNote);

  // 결과 병합
  const allNotes = [...ownedNotes, ...sharedNotes];
  const uniqueNotesMap = new Map();
  allNotes.forEach(note => uniqueNotesMap.set(note.id, note));
  const uniqueNotes = Array.from(uniqueNotesMap.values());

  // 관련 사용자 정보 가져오기 (이름 표시용)
  // unique UIDs 수집: 작성자(userId) 및 공유 대상(sharedWith)
  const userIdsToFetch = new Set();
  uniqueNotes.forEach(note => {
    if (note.userId) userIdsToFetch.add(note.userId);
    if (note.sharedWith && Array.isArray(note.sharedWith)) {
      note.sharedWith.forEach(uid => userIdsToFetch.add(uid));
    }
  });

  // 사용자 정보 조회 (캐싱을 위해 Map 사용)
  const userMap = new Map();
  // 한 번에 가져오기 위해 Promise.all 사용 (in query limit 10 회피 위해 개별 조회 또는 chunk)
  // 소규모 앱이므로 개별 조회 병렬 처리
  const userPromises = Array.from(userIdsToFetch).map(uid =>
    getDoc(doc(db, 'users', uid)).then(userSnap => {
      if (userSnap.exists()) {
        userMap.set(uid, userSnap.data().name || 'Unknown');
      }
    }).catch(err => console.error(`Failed to fetch user ${uid}`, err))
  );

  await Promise.all(userPromises);

  // 노트 객체에 이름 정보 주입
  const enrichedNotes = uniqueNotes.map(note => {
    // 작성자 이름
    const ownerName = userMap.get(note.userId) || 'Unknown';

    // 공유 대상 이름 목록
    const sharedWithNames = (note.sharedWith || [])
      .map(uid => userMap.get(uid) || 'Unknown') // 이름 없는 경우 'Unknown' 처리 (인덱스 유지)

    return {
      ...note,
      ownerName,
      sharedWithNames,
    };
  });

  return enrichedNotes;
};

/**
 * 새 메모 생성
 * @param {Object} note - 메모 데이터
 */
export const createNote = async (note) => {
  // Ensure we have a uid. If note doesn't have it, we can't save it properly for the user.
  // The frontend should pass 'userId' or 'uid' in the note object, 
  // OR we rely on note having it. 
  // Scanning previous usage: fetchNotes takes userId. 
  // Let's assume the note object passed here includes `uid` or `userId`.
  // If not, we might need to get current user from auth, but passing it is cleaner.

  const noteData = {
    ...note,
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString(),
  };

  // ID가 있으면 setDoc으로 지정된 ID 사용, 없으면 addDoc으로 자동 생성
  if (note.id) {
    await setDoc(doc(db, NOTES_COLLECTION, note.id), noteData);
    return { ...noteData };
  } else {
    const docRef = await addDoc(collection(db, NOTES_COLLECTION), noteData);
    return { id: docRef.id, ...noteData };
  }
};

/**
 * 메모 수정
 * @param {Object} note - 수정할 메모 데이터 (id 포함)
 */
export const updateNote = async (note) => {
  const noteRef = doc(db, NOTES_COLLECTION, note.id);
  const { id, ...updateData } = note;

  // 수정 시간 업데이트
  updateData.updatedAt = new Date().toISOString();

  await updateDoc(noteRef, updateData);

  // Return the updated note object
  return { id, ...updateData };
};

/**
 * 메모 삭제
 * @param {string} id - 삭제할 메모 ID
 */
export const deleteNote = async (id) => {
  await deleteDoc(doc(db, NOTES_COLLECTION, id));
  return { id }; // Return id to confirm deletion
};
