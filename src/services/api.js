import { db } from './firebase';
import {
  collection,
  addDoc,
  getDocs,
  doc,
  updateDoc,
  deleteDoc,
  query,
  where,
  Timestamp,
} from 'firebase/firestore';

const NOTES_COLLECTION = 'notes';

// Helper to convert Firestore doc to Note object
const docToNote = (doc) => {
  const data = doc.data();
  return {
    id: doc.id,
    ...data,
    // Convert Firestore Timestamp to ISO string if needed, or keeping it as is 
    // depending on frontend usage. Existing app likely expects ISO strings for dates 
    // if generated by new Date().toISOString()
    createdAt: data.createdAt instanceof Timestamp ? data.createdAt.toDate().toISOString() : data.createdAt,
    updatedAt: data.updatedAt instanceof Timestamp ? data.updatedAt.toDate().toISOString() : data.updatedAt,
  };
};

export const fetchNotes = async (userId) => {
  if (!userId) return [];

  const notesRef = collection(db, NOTES_COLLECTION);

  // 1. 내가 작성한 메모
  const ownedQuery = query(
    notesRef,
    where('userId', '==', userId)
  );

  // 2. 나에게 공유된 메모
  const sharedQuery = query(
    notesRef,
    where('sharedWith', 'array-contains', userId)
  );

  const [ownedSnapshot, sharedSnapshot] = await Promise.all([
    getDocs(ownedQuery),
    getDocs(sharedQuery),
  ]);

  const ownedNotes = ownedSnapshot.docs.map(docToNote);
  const sharedNotes = sharedSnapshot.docs.map(docToNote);

  // 클라이언트 사이드 병합 및 중복 제거
  const allNotes = [...ownedNotes, ...sharedNotes];
  const uniqueNotesMap = new Map();

  allNotes.forEach(note => {
    uniqueNotesMap.set(note.id, note);
  });

  return Array.from(uniqueNotesMap.values());
};

export const createNote = async (note) => {
  // Ensure we have a uid. If note doesn't have it, we can't save it properly for the user.
  // The frontend should pass 'userId' or 'uid' in the note object, 
  // OR we rely on note having it. 
  // Scanning previous usage: fetchNotes takes userId. 
  // Let's assume the note object passed here includes `uid` or `userId`.
  // If not, we might need to get current user from auth, but passing it is cleaner.

  const noteData = {
    ...note,
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString(),
  };

  // Remove id if present before adding (Firestore generates ID)
  delete noteData.id;

  const docRef = await addDoc(collection(db, NOTES_COLLECTION), noteData);
  return { id: docRef.id, ...noteData };
};

export const updateNote = async (note) => {
  const noteRef = doc(db, NOTES_COLLECTION, note.id);
  const { id, ...updateData } = note;

  // Update timestamp
  updateData.updatedAt = new Date().toISOString();

  await updateDoc(noteRef, updateData);

  // Return the updated note object
  return { id, ...updateData };
};

export const deleteNote = async (id) => {
  await deleteDoc(doc(db, NOTES_COLLECTION, id));
  return { id }; // Return id to confirm deletion
};

